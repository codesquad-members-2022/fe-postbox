# 월요일

## 📌 페어프로그래밍 룰 정하기

### 1. 역할

- 네비게이터 : 코드를 설계하고 지시
- 드라이버 : 지시대로 수행하되 궁금한점은 바로 질문

### 2. 진행 방식

- 시간과 관계없이 기능 단위로 역할 스위치 (좀 더 효율적으로 코드를 짜기 위함)

  > 예) 계산기 기능이 구현되면 역할 스위치

- 기능당 30분의 시간제한을 두고 시간이 초과되면 무조건 역할 교체
- 만약 30분 이전에 기능구현이 완료되면 역할을 바꾸지 않고 남은 시간동안 생각정리 (드라이버가 이해 못한 부분을 질문한다거나)

### 3. 시간 관리

- 기준은 30분 역할 수행 / 5분 휴식
- 오전은 총 120분이므로 30분 / 5분 2회 반복 후 20분 휴식, 30분 역할 수행 후(12:25분에 종료) 점심~
- 오후는 총 180분이므로 25분 / 5분 4회 반복 후 30분 휴식, 25분 역할 수행 후(4:50분에 종료)10분간 하루 마무리

### 4. 코드 공유 방법

- vscode live share로 공동 repo에서 작업
- 커밋은 기능단위로 드라이버가 커밋

### 5. 예외 사항

- 첫날 설계단계에서는 시간과 관계없이 기능별로 설계과 완료될때까지 토론
- 드라이버가 너무 자주 질문을 해서 시비거는 느낌이 들어도 이해할 것

## 📌 내일 공부해 올 키워드

- 돔 트리 구조 파악
- 탐색 알고리즘 공부 (DFS, 백트래킹)

# 화요일

## 📌 커스텀 쿼리셀렉터 구현하기

1. DOM 트리 body 태그부터 깊이 우선 탐색을 한다.
2. classList.contains를 사용해 currentNode가 찾는 클래스를 가지고 있는지 확인한다.
3. 가지고 있다면 리턴한다.

- 참고한 DFS 코드
  ```
  preOrder() {
    const finalData = [];
    function traverse(node) {
      if(node.left) {
        traverse(node.left);
      }
      if(node.right) {
        traverse(node.right);
      }
    }
    traverse(this.root);
    return finalData;
  }
  ```

## 📌 미션1 구현

### 1. 제약사항

1. 마을 크기를 정한다.
2. 넓이 기준으로 가장 큰 마을들을 배치한다.
3. 자식 마을은 부모 마을의 %로 크기를 갖는다.
4. 우체통은 마을보다 클 수 없다.
5. 가장 작은 마을은 가장 작은 우체통보다 커야한다.

### 2. 객체 단위

- 마을 지도
  - 크기
  - 마을 배열
- 마을
  - 크기
  - 내부 마을 배열
  - 우체통 유무
- 우체통
  - 크기

### 3. 구현 목표
> 조건에 맞게 마을을 생성해주는 함수

- [] 최상위 마을들의 크기의 합이 마을 지도의 크기를 넘지 않는다.
- [] 마을 지도 객체 만들고
- [] 마을 객체를 만들고 
- [] 마을 지도 넓이를 구하기 근데 절반만 씀
- [] 마을을 생성해서 마을 지도 넓이/2 - 마을 넓이
- [] 반복
- [] 최상위 마을을 만들고 넓이가 조건에 맞는지 
- [] 판단해주고 최상위마을들을 map배열에 넣어주는 함수

# 수요일

### 구현 목표
- map.towns를 순회
- 재귀로 내부 town들이 생성되게 만든다

### 추가된 제약조건
- 한 마을의 내부에 생길 수 있는 마을 최대갯수는 3개를 넘지 못한다.

### 추가 구현 목표
- 자식마을의 크기를 상수가 아닌 퍼센티지로 변경
- generateRandom 함수의 범위를 퍼센티지에 맞게 변경
- createTownIns를 비율이 리턴되도록 변경
- 가로 세로가 부모의 가로 세로의 비율로 선절하도록 수정

# 목요일

### 구현 목표
- 랜덤하게 마을을 화면에 렌더링하는 방법
1. poistion:relative(left, bottom)에 랜덤값을 줘서 랜덤으로 마을을 배치
2. 배치된 마을들이 겹치는 알아보는 함수 구현
    - 두 마을을 비교한다고 가정하면
    - 두 width의 차이의 절대값 = |(A의 left+width) - (B의 left+width)|
    - 두 height의 차이의 절대값 = |(A의 bottom+height) - (B의 bottom+height)|
    - 두 값이 모두 B의 width와 height보다 작으면 겹친다고 판단,한 값이라도 크면 안 겹침

  3. [{
 width: ~~
 heigth: ~~
},b,c,b,e]